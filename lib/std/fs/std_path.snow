/**
@module std_path
@summary 基础路径字符串工具，提供拼接、规范化与拆解能力。
*/
module: std_path
    import: std_string

    /**
    @function join
    @summary 将 base 与 sub 拼为单一路径并规范化。
    */
    function: join
        params:
            declare base: string
            declare sub: string
        returns: string
        body:
            if base == "" then
                return std_path.normalize(sub)
            end if
            if sub == "" then
                return std_path.normalize(base)
            end if

            declare subBytes: byte[] = std_string.toBytes(sub)
            declare subLen: int = syscall("0x1801", subBytes)
            if subLen > 0 && std_path._isSeparator(subBytes[0]) then
                return std_path.normalize(sub)
            end if

            declare combined: string = base
            if std_path._endsWithSep(combined) == false then
                combined = combined + "/"
            end if
            combined = combined + sub

            return std_path.normalize(combined)
        end body
    end function

    /**
    @function basename
    @summary 返回路径的文件名部分。
    */
    function: basename
        params:
            declare path: string
        returns: string
        body:
            declare norm: string = std_path.normalize(path)
            declare len: int = std_string.length(norm)
            if len == 0 then
                return ""
            end if

            declare data: byte[] = std_string.toBytes(norm)
            declare lastSep: int = -1
            declare i: int = 0
            loop:
                init:
                    i = i
                cond:
                    i < len
                step:
                    i = i + 1
                body:
                    if std_path._isSeparator(data[i]) then
                        lastSep = i
                    end if
                end body
            end loop

            if lastSep == -1 then
                return norm
            end if
            if lastSep == len - 1 then
                return "/"
            end if

            return std_string.substring(norm, lastSep + 1, len)
        end body
    end function

    /**
    @function dirname
    @summary 返回路径的目录部分。
    */
    function: dirname
        params:
            declare path: string
        returns: string
        body:
            declare norm: string = std_path.normalize(path)
            declare len: int = std_string.length(norm)
            if len == 0 then
                return "."
            end if

            declare data: byte[] = std_string.toBytes(norm)
            declare lastSep: int = -1
            declare i: int = 0
            loop:
                init:
                    i = i
                cond:
                    i < len
                step:
                    i = i + 1
                body:
                    if std_path._isSeparator(data[i]) then
                        lastSep = i
                    end if
                end body
            end loop

            if lastSep == -1 then
                return "."
            end if
            if lastSep == 0 then
                return "/"
            end if

            return std_string.substring(norm, 0, lastSep)
        end body
    end function

    /**
    @function extname
    @summary 返回路径的扩展名（含点），无扩展名返回空字符串。
    */
    function: extname
        params:
            declare path: string
        returns: string
        body:
            declare norm: string = std_path.normalize(path)
            declare len: int = std_string.length(norm)
            if len == 0 then
                return ""
            end if

            declare data: byte[] = std_string.toBytes(norm)
            declare lastSep: int = -1
            declare lastDot: int = -1

            declare i: int = 0
            loop:
                init:
                    i = i
                cond:
                    i < len
                step:
                    i = i + 1
                body:
                    declare ch: int = data[i]
                    if ch == 46 then              // '.'
                        lastDot = i
                    end if
                    if std_path._isSeparator(ch) then
                        lastSep = i
                        lastDot = -1
                    end if
                end body
            end loop

            if lastDot == -1 then
                return ""
            end if
            if lastDot == len - 1 then
                return ""
            end if

            return std_string.substring(norm, lastDot, len)
        end body
    end function

    /**
    @function normalize
    @summary 规范化路径，折叠重复分隔符并处理 "." 与 ".."。
    */
    function: normalize
        params:
            declare path: string
        returns: string
        body:
            declare rawLen: int = std_string.length(path)
            if rawLen == 0 then
                return "."
            end if

            declare bytes: byte[] = std_string.toBytes(path)
            declare len: int = syscall("0x1801", bytes)
            declare absolute: boolean = false
            if len > 0 && std_path._isSeparator(bytes[0]) then
                absolute = true
            end if

            declare segments: any = []
            declare segCount: int = 0
            declare current: string = ""

            declare i: int = 0
            loop:
                init:
                    i = i
                cond:
                    i <= len
                step:
                    i = i + 1
                body:
                    declare ch: int
                    if i == len then
                        ch = 47    // sentinel '/'
                    else
                        ch = bytes[i]
                        if ch == 92 then
                            ch = 47
                        end if
                    end if

                    if std_path._isSeparator(ch) then
                        if current != "" then
                            if current == "." then
                                // skip
                            else
                                if current == ".." then
                                    if segCount > 0 then
                                        segCount = segCount - 1
                                    else
                                        if absolute == false then
                                            syscall("0x1803", segments, segCount, current)
                                            segCount = segCount + 1
                                        end if
                                    end if
                                else
                                    syscall("0x1803", segments, segCount, current)
                                    segCount = segCount + 1
                                end if
                            end if
                            current = ""
                        end if
                    else
                        current = current + std_path._fromByte(ch)
                    end if
                end body
            end loop

            if segCount == 0 then
                if absolute then
                    return "/"
                end if
                return "."
            end if

            declare result: string = ""
            if absolute then
                result = "/"
            end if

            declare idx: int = 0
            loop:
                init:
                    idx = idx
                cond:
                    idx < segCount
                step:
                    idx = idx + 1
                body:
                    if result != "" && std_path._endsWithSep(result) == false then
                        result = result + "/"
                    end if
                    declare segVal: string = "" + syscall("0x1802", segments, idx)
                    result = result + segVal
                end body
            end loop

            return result
        end body
    end function

    /**
    @function _isSeparator
    @summary 判断字符是否为路径分隔符。
    */
    function: _isSeparator
        params:
            declare ch: int
        returns: boolean
        body:
            if ch == 47 then
                return true
            end if
            if ch == 92 then
                return true
            end if
            return false
        end body
    end function

    /**
    @function _endsWithSep
    @summary 判断字符串是否以分隔符结尾。
    */
    function: _endsWithSep
        params:
            declare s: string
        returns: boolean
        body:
            declare len: int = std_string.length(s)
            if len == 0 then
                return false
            end if
            declare bytes: byte[] = std_string.toBytes(s)
            declare last: int = bytes[len - 1]
            return std_path._isSeparator(last)
        end body
    end function

    /**
    @function _fromByte
    @summary 将单个字节值转为字符串。
    */
    function: _fromByte
        params:
            declare b: int
        returns: string
        body:
            return std_string._charToString(b)
        end body
    end function

end module
