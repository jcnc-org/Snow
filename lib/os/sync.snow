// sync module: 并发原语系统调用封装
// ──────────────────────────────────────────────
//  • 0x1600  MUTEX_NEW        → 创建互斥量
//  • 0x1601  MUTEX_LOCK       → 加锁互斥量
//  • 0x1602  MUTEX_TRYLOCK    → 尝试加锁互斥量
//  • 0x1603  MUTEX_UNLOCK     → 解锁互斥量
//  • 0x1604  COND_NEW         → 创建条件变量
//  • 0x1605  COND_WAIT        → 等待条件变量
//  • 0x1606  COND_SIGNAL      → 唤醒一个等待线程
//  • 0x1607  COND_BROADCAST   → 唤醒所有等待线程
//  • 0x1608  SEM_NEW          → 创建信号量
//  • 0x1609  SEM_WAIT         → 等待信号量
//  • 0x160A  SEM_POST         → 释放信号量
//  • 0x160B  RWLOCK_NEW       → 创建读写锁
//  • 0x160C  RWLOCK_RLOCK     → 加读锁
//  • 0x160D  RWLOCK_WLOCK     → 加写锁
//  • 0x160E  RWLOCK_UNLOCK    → 解锁读写锁
// ──────────────────────────────────────────────

module: sync

    /**
     * mutex_new()
     *
     * <b>Stack</b>：入参 () → 出参 (mid:int)
     *
     * <b>语义</b>：创建并返回一个新的互斥量 ID。
     */
    function: mutex_new
        returns: int
        body:
            return syscall("0x1600")
        end body
    end function

    /**
     * mutex_lock(mid)
     *
     * <b>Stack</b>：入参 (mid:int) → 出参 (rc:int)
     *
     * <b>语义</b>：阻塞直到获取互斥量。
     */
    function: mutex_lock
        params:
            declare mid:int
        returns: int
        body:
            return syscall("0x1601", mid)
        end body
    end function

    /**
     * mutex_trylock(mid)
     *
     * <b>Stack</b>：入参 (mid:int) → 出参 (ok:int)
     *
     * <b>语义</b>：立即尝试获取互斥量。
     * <b>返回</b>：成功=1，失败=0。
     */
    function: mutex_trylock
        params:
            declare mid:int
        returns: int
        body:
            return syscall("0x1602", mid)
        end body
    end function

    /**
     * mutex_unlock(mid)
     *
     * <b>Stack</b>：入参 (mid:int) → 出参 (rc:int)
     *
     * <b>语义</b>：释放互斥量。
     */
    function: mutex_unlock
        params:
            declare mid:int
        returns: int
        body:
            return syscall("0x1603", mid)
        end body
    end function

    /**
     * cond_new()
     *
     * <b>Stack</b>：入参 () → 出参 (cid:int)
     *
     * <b>语义</b>：创建条件变量。
     */
    function: cond_new
        returns: int
        body:
            return syscall("0x1604")
        end body
    end function

    /**
     * cond_wait(cid, mid, timeout?)
     *
     * <b>Stack</b>：入参 (cid:int, mid:int, timeout_ms:int?) → 出参 (reason:int)
     *
     * <b>语义</b>：等待条件变量，返回前重新加锁。
     * <b>返回</b>：0=唤醒，1=超时，-1=中断。
     */
    function: cond_wait
        params:
            declare cid:int
            declare mid:int
            declare timeout:int
        returns: int
        body:
            return syscall("0x1605", cid, mid, timeout)
        end body
    end function

    /**
     * cond_signal(cid)
     *
     * <b>Stack</b>：入参 (cid:int) → 出参 (rc:int)
     *
     * <b>语义</b>：唤醒一个等待线程。
     */
    function: cond_signal
        params:
            declare cid:int
        returns: int
        body:
            return syscall("0x1606", cid)
        end body
    end function

    /**
     * cond_broadcast(cid)
     *
     * <b>Stack</b>：入参 (cid:int) → 出参 (rc:int)
     *
     * <b>语义</b>：唤醒所有等待线程。
     */
    function: cond_broadcast
        params:
            declare cid:int
        returns: int
        body:
            return syscall("0x1607", cid)
        end body
    end function

    /**
     * sem_new(init)
     *
     * <b>Stack</b>：入参 (init:int) → 出参 (sid:int)
     *
     * <b>语义</b>：创建一个指定初值的信号量。
     */
    function: sem_new
        params:
            declare init1:int
        returns: int
        body:
            return syscall("0x1608", init1)
        end body
    end function

    /**
     * sem_wait(sid, timeout?)
     *
     * <b>Stack</b>：入参 (sid:int, timeout_ms:int?) → 出参 (rc:int)
     *
     * <b>语义</b>：等待信号量。
     * <b>返回</b>：1=成功，0=超时，-1=中断。
     */
    function: sem_wait
        params:
            declare sid:int
            declare timeout:int
        returns: int
        body:
            return syscall("0x1609", sid, timeout)
        end body
    end function

    /**
     * sem_post(sid)
     *
     * <b>Stack</b>：入参 (sid:int) → 出参 (rc:int)
     *
     * <b>语义</b>：释放信号量。
     */
    function: sem_post
        params:
            declare sid:int
        returns: int
        body:
            return syscall("0x160A", sid)
        end body
    end function

    /**
     * rwlock_new()
     *
     * <b>Stack</b>：入参 () → 出参 (rwl:int)
     *
     * <b>语义</b>：创建读写锁。
     */
    function: rwlock_new
        returns: int
        body:
            return syscall("0x160B")
        end body
    end function

    /**
     * rwlock_rlock(rwl)
     *
     * <b>Stack</b>：入参 (rwl:int) → 出参 (rc:int)
     *
     * <b>语义</b>：加读锁。
     */
    function: rwlock_rlock
        params:
            declare rwl:int
        returns: int
        body:
            return syscall("0x160C", rwl)
        end body
    end function

    /**
     * rwlock_wlock(rwl)
     *
     * <b>Stack</b>：入参 (rwl:int) → 出参 (rc:int)
     *
     * <b>语义</b>：加写锁。
     */
    function: rwlock_wlock
        params:
            declare rwl:int
        returns: int
        body:
            return syscall("0x160D", rwl)
        end body
    end function

    /**
     * rwlock_unlock(rwl)
     *
     * <b>Stack</b>：入参 (rwl:int) → 出参 (rc:int)
     *
     * <b>语义</b>：释放读写锁。
     */
    function: rwlock_unlock
        params:
            declare rwl:int
        returns: int
        body:
            return syscall("0x160E", rwl)
        end body
    end function

end module
