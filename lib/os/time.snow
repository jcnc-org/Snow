/**
@module time
@summary 时钟与睡眠相关系统调用模块，封装时间获取和线程休眠等操作。
@syscalls
  0x1700 CLOCK_GETTIME 获取时钟纳秒时间戳（REALTIME=0, MONO=1）
  0x1701 NANOSLEEP     让当前线程按纳秒挂起
  0x1702 TIMEOFDAY     兼容式获取 (sec, usec)
  0x1703 TICK_MS       获取单调时钟的毫秒计数（用于计时）
*/
module: time

    // 常用时钟 ID
    globals:
        declare REALTIME:int = 0
        declare MONO:int     = 1

    /**
    @function clock_gettime
    @summary 返回给定时钟的纳秒时间戳。
    @param clockId 时钟ID，REALTIME=0：自 Unix 纪元以来的墙钟时间（单位 ns），MONO=1：单调时钟（适合测量间隔）
    @returns long 成功时返回纳秒时间
    @throws IllegalArgumentException 若 clockId 非法或不被支持时抛出异常
    */
    function: clock_gettime
        params:
            declare clockId:int
        returns: long
        body:
            return syscall("0x1700", clockId)
        end body
    end function

    /**
    @function nanosleep
    @summary 让当前线程挂起指定的纳秒数。
    @param ns 要挂起的纳秒数
    @returns int 成功返回 0
    @throws InterruptedException 被中断时可能抛出异常，调用者应处理或恢复中断状态
    */
    function: nanosleep
        params:
            declare ns: long
        returns: int
        body:
            return syscall("0x1701", ns)
        end body
    end function

    /**
    @function timeofday_raw
    @summary 兼容式获取 (sec, usec)。
    @returns any 成功返回两个值：sec:long 和 usec:int（注意压栈顺序由实现约定）
    */
    function: timeofday_raw
        returns: any
        body:
            return syscall("0x1702")
        end body
    end function

    /**
    @function tick_ms
    @summary 返回单调计数的毫秒数（适合计算时间间隔，不是绝对时间）。
    @returns long 成功返回单调毫秒数
    */
    function: tick_ms
        returns: long
        body:
            return syscall("0x1703")
        end body
    end function

    // ─────────────── 便捷封装（基于上面四个原始 syscall） ───────────────

    /**
    @function now_ns
    @summary 以纳秒返回墙钟时间（REALTIME）。
    @returns long 墙钟时间纳秒数
    */
    function: now_ns
        returns: long
        body:
            return clock_gettime(REALTIME)
        end body
    end function

    /**
    @function mono_ns
    @summary 以纳秒返回单调时钟（MONO）。
    @returns long 单调时钟纳秒数
    */
    function: mono_ns
        returns: long
        body:
            return clock_gettime(MONO)
        end body
    end function

    /**
    @function now_ms
    @summary 以毫秒返回墙钟时间。
    @returns long 墙钟时间毫秒数
    */
    function: now_ms
        returns: long
        body:
            // 1_000_000 ns = 1 ms
            declare ns: long = clock_gettime(REALTIME)
            return ns / 1000000
        end body
    end function

    /**
    @function mono_ms
    @summary 以毫秒返回单调时钟。
    @returns long 单调时钟毫秒数
    */
    function: mono_ms
        returns: long
        body:
            declare ns: long = clock_gettime(MONO)
            return ns / 1000000
        end body
    end function

    /**
    @function epoch_sec
    @summary 返回自 Unix 纪元以来的秒数（long）。
    @returns long 自 Unix 纪元以来的秒数
    */
    function: epoch_sec
        returns: long
        body:
            declare ns: long = clock_gettime(REALTIME)
            return ns / 1000000000
        end body
    end function

    /**
    @function epoch_usec_in_sec
    @summary 返回当前秒内的微秒部分（0..999_999）。
    @returns long 当前秒内的微秒部分
    */
    function: epoch_usec_in_sec
        returns: long
        body:
            declare ns: long = clock_gettime(REALTIME)
            declare us: long = ns / 1000
            // 取当前秒内的微秒
            declare usec:long = us % 1000000
            return usec
        end body
    end function

    /**
    @function sleep_ms
    @summary 以毫秒为单位的睡眠。
    @param ms 要睡眠的毫秒数
    @returns int 成功返回 0
    */
    function: sleep_ms
        params:
            declare ms:int
        returns: int
        body:
            // 避免中间溢出：先转 long 再乘
            declare ns: long = (ms + 0) * 1000000
            return nanosleep(ns)
        end body
    end function

    /**
    @function sleep_us
    @summary 以微秒为单位的睡眠。
    @param us 要睡眠的微秒数
    @returns int 成功返回 0
    */
    function: sleep_us
        params:
            declare us:int
        returns: int
        body:
            declare ns: long = (us + 0) * 1000
            return nanosleep(ns)
        end body
    end function

end module