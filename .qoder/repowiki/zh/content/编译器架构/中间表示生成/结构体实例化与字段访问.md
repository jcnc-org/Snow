# 结构体实例化与字段访问

<cite>
**本文档引用的文件**   
- [StructNode.java](file://src/main/java/org/jcnc/snow/compiler/parser/ast/StructNode.java)
- [NewExpressionNode.java](file://src/main/java/org/jcnc/snow/compiler/parser/ast/NewExpressionNode.java)
- [NewObjectParselet.java](file://src/main/java/org/jcnc/snow/compiler/parser/expression/NewObjectParselet.java)
- [NewHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/NewHandler.java)
- [MemberExpressionNode.java](file://src/main/java/org/jcnc/snow/compiler/parser/ast/MemberExpressionNode.java)
- [MemberParselet.java](file://src/main/java/org/jcnc/snow/compiler/parser/expression/MemberParselet.java)
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java)
- [IRBuilderScope.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/core/IRBuilderScope.java)
- [IRProgramBuilder.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/core/IRProgramBuilder.java)
- [StructParser.java](file://src/main/java/org/jcnc/snow/compiler/parser/struct/StructParser.java)
</cite>

## 目录
1. [简介](#简介)
2. [结构体定义与解析](#结构体定义与解析)
3. [结构体实例化](#结构体实例化)
4. [字段访问机制](#字段访问机制)
5. [继承与字段布局](#继承与字段布局)
6. [字段访问IR生成](#字段访问IR生成)
7. [总结](#总结)

## 简介
本文档详细分析Snow编译器中结构体实例化与字段访问的实现机制。通过解析器、语义分析和中间代码生成三个阶段，系统地阐述了从源代码到中间表示的转换过程。重点包括结构体的定义语法、`new`表达式的解析、成员访问操作的处理，以及继承场景下的字段布局管理。

## 结构体定义与解析
Snow语言中的结构体通过`struct`关键字定义，支持字段、构造函数和方法的声明。结构体可以继承父类，形成继承链。

```mermaid
flowchart TD
Start["开始解析结构体"] --> CheckKeyword["检查 'struct' 关键字"]
CheckKeyword --> ReadName["读取结构体名称"]
ReadName --> CheckParent["检查是否有父类"]
CheckParent --> |有父类| ReadParent["读取父类名称"]
CheckParent --> |无父类| Continue["继续"]
ReadParent --> Continue
Continue --> ExpectNewline["期望换行符"]
ExpectNewline --> ParseBody["解析结构体主体"]
ParseBody --> |fields块| ParseFields["解析字段声明"]
ParseBody --> |init块| ParseInit["解析构造函数"]
ParseBody --> |function块| ParseFunction["解析方法"]
ParseFields --> ParseBody
ParseInit --> ParseBody
ParseFunction --> ParseBody
ParseBody --> CheckEnd["检查 'end struct'"]
CheckEnd --> End["结构体解析完成"]
```

**图示来源**
- [StructParser.java](file://src/main/java/org/jcnc/snow/compiler/parser/struct/StructParser.java#L1-L186)

**本节来源**
- [StructNode.java](file://src/main/java/org/jcnc/snow/compiler/parser/ast/StructNode.java#L1-L52)
- [StructParser.java](file://src/main/java/org/jcnc/snow/compiler/parser/struct/StructParser.java#L1-L186)

## 结构体实例化
结构体实例化通过`new`关键字完成，语法为`new TypeName(arg1, arg2, ...)`。该过程涉及解析、语义分析和中间代码生成三个阶段。

### 解析阶段
`NewObjectParselet`负责解析`new`表达式，生成`NewExpressionNode` AST节点。

```mermaid
flowchart TD
Start["开始解析 new 表达式"] --> ReadNew["读取 'new' 关键字"]
ReadNew --> ReadType["读取类型名称"]
ReadType --> CheckParen["检查 '('"]
CheckParen --> ParseArgs["解析参数列表"]
ParseArgs --> |有参数| BuildArg["构建参数表达式"]
ParseArgs --> |无参数| Continue["继续"]
BuildArg --> ParseArgs
ParseArgs --> CheckClose["检查 ')'"]
CheckClose --> CreateNode["创建 NewExpressionNode"]
CreateNode --> End["new 表达式解析完成"]
```

**图示来源**
- [NewObjectParselet.java](file://src/main/java/org/jcnc/snow/compiler/parser/expression/NewObjectParselet.java#L1-L64)

### 语义分析
`NewExpressionAnalyzer`对`new`表达式进行类型检查，确保目标类型存在且构造函数参数匹配。

**本节来源**
- [NewExpressionNode.java](file://src/main/java/org/jcnc/snow/compiler/parser/ast/NewExpressionNode.java#L1-L51)
- [NewObjectParselet.java](file://src/main/java/org/jcnc/snow/compiler/parser/expression/NewObjectParselet.java#L1-L64)
- [NewExpressionAnalyzer.java](file://src/main/java/org/jcnc/snow/compiler/semantic/analyzers/expression/NewExpressionAnalyzer.java#L1-L31)

## 字段访问机制
字段访问通过点操作符`.`实现，语法为`object.field`。该机制支持普通对象字段访问、模块常量访问和继承链上的字段查找。

### 解析阶段
`MemberParselet`负责解析成员访问表达式，生成`MemberExpressionNode` AST节点。

```mermaid
flowchart TD
Start["开始解析成员访问"] --> ReadObject["读取对象表达式"]
ReadObject --> CheckDot["检查 '.' 操作符"]
CheckDot --> ReadMember["读取成员名称"]
ReadMember --> CreateNode["创建 MemberExpressionNode"]
CreateNode --> End["成员访问解析完成"]
```

**图示来源**
- [MemberParselet.java](file://src/main/java/org/jcnc/snow/compiler/parser/expression/MemberParselet.java#L1-L50)

### 中间代码生成
`MemberHandler`将成员访问表达式转换为底层的`__index_*`函数调用，根据字段类型选择合适的访问通道。

```mermaid
flowchart TD
Start["开始处理成员访问"] --> CheckModule["检查是否为模块常量"]
CheckModule --> |是| LoadConst["生成常量加载指令"]
CheckModule --> |否| CalcObject["计算对象寄存器"]
CalcObject --> ResolveType["解析对象类型"]
ResolveType --> CalcIndex["计算字段下标"]
CalcIndex --> CheckField["检查字段是否存在"]
CheckField --> |不存在| ThrowError["抛出异常"]
CheckField --> |存在| SelectFunc["选择 __index_* 函数"]
SelectFunc --> GenerateCall["生成函数调用指令"]
GenerateCall --> End["成员访问处理完成"]
```

**图示来源**
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java#L1-L198)

**本节来源**
- [MemberExpressionNode.java](file://src/main/java/org/jcnc/snow/compiler/parser/ast/MemberExpressionNode.java#L1-L35)
- [MemberParselet.java](file://src/main/java/org/jcnc/snow/compiler/parser/expression/MemberParselet.java#L1-L50)
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java#L1-L198)

## 继承与字段布局
Snow支持结构体继承，通过`parent`字段指定父类。字段布局管理确保继承链上的字段下标正确计算，避免重复累计。

### 字段下标计算
`resolveFieldIndex`方法根据结构体继承链计算字段的全局下标。

```mermaid
flowchart TD
Start["开始计算字段下标"] --> CheckSelf["检查字段是否在本类声明"]
CheckSelf --> |是| CheckFlattened["检查布局是否扁平化"]
CheckFlattened --> |是| ReturnSelfIndex["返回本类布局下标"]
CheckFlattened --> |否| CalcAncestor["计算祖先字段数"]
CalcAncestor --> ReturnOffsetIndex["返回偏移后下标"]
CheckSelf --> |否| TraverseAncestor["遍历祖先类"]
TraverseAncestor --> |找到字段| ReturnAncestorIndex["返回祖先布局下标"]
TraverseAncestor --> |未找到| ReturnNull["返回 null"]
```

**图示来源**
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java#L123-L157)

### 布局扁平化判断
`isFlattenedWithParent`方法判断子类布局是否已包含父类字段。

```mermaid
flowchart TD
Start["开始判断布局扁平化"] --> GetParent["获取父类名称"]
GetParent --> |无父类| ReturnTrue["返回 true"]
GetParent --> |有父类| GetParentLayout["获取父类布局"]
GetParentLayout --> |无布局| ReturnTrue["返回 true"]
GetParentLayout --> |有布局| CheckField["检查父类字段是否在子类布局中"]
CheckField --> |存在| ReturnTrue["返回 true"]
CheckField --> |不存在| ReturnFalse["返回 false"]
```

**图示来源**
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java#L168-L176)

**本节来源**
- [IRBuilderScope.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/core/IRBuilderScope.java#L1-L200)
- [IRProgramBuilder.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/core/IRProgramBuilder.java#L98-L154)
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java#L110-L198)

## 中间表示（IR）生成
结构体实例化和字段访问的中间表示生成涉及多个处理器的协作，最终转换为底层的函数调用和指令。

### 实例化IR生成
`NewHandler`将`new`表达式转换为IR指令序列。

```mermaid
flowchart TD
Start["开始处理 new 表达式"] --> AllocReg["分配实例寄存器"]
AllocReg --> InitStruct["初始化空结构"]
InitStruct --> LoopArgs["遍历构造参数"]
LoopArgs --> |有参数| ResolveType["解析字段类型"]
LoopArgs --> |无参数| CheckStruct["检查是否为结构体"]
ResolveType --> BuildArg["构建参数表达式"]
BuildArg --> LoadIndex["加载字段下标"]
LoadIndex --> SelectSetFunc["选择 __setindex_* 函数"]
SelectSetFunc --> GenerateSetCall["生成赋值调用"]
GenerateSetCall --> LoopArgs
CheckStruct --> |是| CallConstructor["调用构造函数"]
CallConstructor --> End["返回实例寄存器"]
```

**图示来源**
- [NewHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/NewHandler.java#L33-L131)

### 字段访问IR生成
`MemberHandler`将成员访问转换为`__index_*`函数调用。

```mermaid
flowchart TD
Start["开始处理成员访问"] --> CheckModuleConst["检查模块常量"]
CheckModuleConst --> |是| GenerateLoadConst["生成常量加载"]
CheckModuleConst --> |否| BuildObject["构建对象表达式"]
BuildObject --> ResolveOwnerType["解析所有者类型"]
ResolveOwnerType --> CalcFieldIndex["计算字段下标"]
CalcFieldIndex --> CheckFieldExist["检查字段是否存在"]
CheckFieldExist --> |不存在| ThrowError["抛出异常"]
CheckFieldExist --> |存在| LoadIndexReg["加载下标寄存器"]
LoadIndexReg --> ResolveFieldType["解析字段类型"]
ResolveFieldType --> SelectIndexFunc["选择 __index_* 函数"]
SelectIndexFunc --> GenerateCall["生成函数调用"]
GenerateCall --> End["返回结果寄存器"]
```

**图示来源**
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java#L48-L113)

**本节来源**
- [NewHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/NewHandler.java#L33-L131)
- [MemberHandler.java](file://src/main/java/org/jcnc/snow/compiler/ir/builder/handlers/MemberHandler.java#L48-L113)

## 总结
Snow编译器通过多层次的解析和转换机制，实现了结构体实例化与字段访问的完整支持。从源代码解析到AST构建，再到语义分析和中间表示生成，每个阶段都精心设计以确保类型安全和运行效率。继承机制和字段布局管理使得结构体能够灵活地组织数据，而`__index_*`和`__setindex_*`系列函数则提供了高效的底层访问通道。