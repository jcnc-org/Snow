package org.jcnc.snow.compiler.ir.core;

/**
 * {@code IROpCode} 枚举类型定义了中间表示（IR）层支持的全部操作码。
 * <p>
 * 每个操作码代表一种低层次、语义明确的中间指令，用于构建目标函数的中间表示。
 * 这些操作涵盖了不同数据位宽的整数与浮点数算术运算、逻辑与比较操作、
 * 数据加载与存储指令、控制流指令（如跳转、条件跳转、标签）、
 * 以及函数调用与返回等功能。
 * <p>
 * 本枚举用于 {@link IRInstruction} 体系结构中，是 IR 指令识别和转换的核心部分，
 * </p>
 */
public enum IROpCode {

    // 整型 ↔ 单精度
    CONV_I32_TO_F32,
    CONV_F32_TO_I32,
    // 整型 ↔ 双精度
    CONV_I32_TO_D64,
    CONV_D64_TO_I32,
    // 单精度 ↔ 双精度
    CONV_F32_TO_D64,
    CONV_D64_TO_F32,


    /* ───── 算术运算（8位整数：byte）───── */
    ADD_B8,    // 8位整型加法：a = b + c
    SUB_B8,    // 8位整型减法：a = b - c
    MUL_B8,    // 8位整型乘法：a = b * c
    DIV_B8,    // 8位整型除法：a = b / c
    NEG_B8,    // 8位整型取负：a = -b

    /* ───── 算术运算（16位整数：short）───── */
    ADD_S16,   // 16位整型加法
    SUB_S16,   // 16位整型减法
    MUL_S16,   // 16位整型乘法
    DIV_S16,   // 16位整型除法
    NEG_S16,   // 16位整型取负

    /* ───── 算术运算（32位整数：int）───── */
    ADD_I32,   // 32位整型加法
    SUB_I32,   // 32位整型减法
    MUL_I32,   // 32位整型乘法
    DIV_I32,   // 32位整型除法
    NEG_I32,   // 32位整型取负

    /* ───── 算术运算（64位整数：long）───── */
    ADD_L64,   // 64位整型加法
    SUB_L64,   // 64位整型减法
    MUL_L64,   // 64位整型乘法
    DIV_L64,   // 64位整型除法
    NEG_L64,   // 64位整型取负

    /* ───── 算术运算（32位浮点数：float）───── */
    ADD_F32,   // 32位浮点加法
    SUB_F32,   // 32位浮点减法
    MUL_F32,   // 32位浮点乘法
    DIV_F32,   // 32位浮点除法
    NEG_F32,   // 32位浮点取负

    /* ───── 算术运算（64位浮点数：double）───── */
    ADD_D64,   // 64位浮点加法
    SUB_D64,   // 64位浮点减法
    MUL_D64,   // 64位浮点乘法
    DIV_D64,   // 64位浮点除法
    NEG_D64,   // 64位浮点取负

    /* ───── 逻辑与比较运算指令（8位整数：byte） ───── */
    CMP_BEQ,    // 8位整数相等比较：a == b
    CMP_BNE,    // 8位整数不等比较：a != b
    CMP_BLT,    // 8位整数小于比较：a < b
    CMP_BGT,    // 8位整数大于比较：a > b
    CMP_BLE,    // 8位整数小于等于：a <= b
    CMP_BGE,    // 8位整数大于等于：a >= b

    /* ───── 逻辑与比较运算指令（16位整数：int） ───── */
    CMP_SEQ,    // 16位整数相等比较：a == b
    CMP_SNE,    // 16位整数不等比较：a != b
    CMP_SLT,    // 16位整数小于比较：a < b
    CMP_SGT,    // 16位整数大于比较：a > b
    CMP_SLE,    // 16位整数小于等于：a <= b
    CMP_SGE,    // 16位整数大于等于：a >= b

    /* ───── 逻辑与比较运算指令（32位整数：int） ───── */
    CMP_IEQ,    // 32位整数相等比较：a == b
    CMP_INE,    // 32位整数不等比较：a != b
    CMP_ILT,    // 32位整数小于比较：a < b
    CMP_IGT,    // 32位整数大于比较：a > b
    CMP_ILE,    // 32位整数小于等于：a <= b
    CMP_IGE,    // 32位整数大于等于：a >= b

    /* ───── 逻辑与比较运算指令（64位整数：long） ───── */
    CMP_LEQ,    // 64位整数相等比较：a == b
    CMP_LNE,    // 64位整数不等比较：a != b
    CMP_LLT,    // 64位整数小于比较：a < b
    CMP_LGT,    // 64位整数大于比较：a > b
    CMP_LLE,    // 64位整数小于等于：a <= b
    CMP_LGE,    // 64位整数大于等于：a >= b

    /* ───── 逻辑与比较运算指令（32位浮点数：float） ───── */
    CMP_FEQ,    // 32位浮点相等比较：a == b
    CMP_FNE,    // 32位浮点不等比较：a != b
    CMP_FLT,    // 32位浮点小于比较：a < b
    CMP_FGT,    // 32位浮点大于比较：a > b
    CMP_FLE,    // 32位浮点小于等于：a <= b
    CMP_FGE,    // 32位浮点大于等于：a >= b

    /* ───── 逻辑与比较运算指令（64位浮点数：double） ───── */
    CMP_DEQ,    // 64位浮点相等比较：a == b
    CMP_DNE,    // 64位浮点不等比较：a != b
    CMP_DLT,    // 64位浮点小于比较：a < b
    CMP_DGT,    // 64位浮点大于比较：a > b
    CMP_DLE,    // 64位浮点小于等于：a <= b
    CMP_DGE,    // 64位浮点大于等于：a >= b

    /* ───── 数据访问与常量操作 ───── */
    LOAD,      // 从内存加载数据至寄存器
    STORE,     // 将寄存器数据写回内存
    CONST,     // 将常量写入目标寄存器

    /* ───── 控制流指令 ───── */
    JUMP,         // 无条件跳转至标签
    LABEL,        // 标签定义

    /* ───── 函数调用与返回 ───── */
    CALL,      // 函数调用
    RET        // 函数返回
}